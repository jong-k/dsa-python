# 그래프 이론

## 목차

1. 문제 리스트
2. 기본 개념

## 1. 문제 리스트

## 2. 기본 개념

#### 인접 행렬 vs 인접 리스트

인접 행렬

- 간선 정보를 저장하기 위헤 O(V^2) 의 메모리 필요
- 특정 간선을 O(1) 에 접근 가능
- 플로이드 워셜에서 사용

인접 리스트

- 간선의 갯수만큼 메모리 필요 O(E)
- 특정 간선을 O(V) 에 접근 가능 (특정 노드의 모든 간선 탐색)
- 다익스트라에서 사용

### 2.1. 서로소 집합 (Disjoint Sets, Union Find)

#### 서로소 집합(유니언 파인드) 자료구조

- 공통 원소가 없는 집합
- 예) {1, 2} 와 {3, 4}
- 유니언 파인드는 아래 2가지 연산을 가짐
  - 유니언(합집합) : 2개의 집합을 하나로 합침 (즉, 두 노드의 루트 노드를 같게 함)
  - 파인드(찾기) : 특정 원소가 속한 집합이 어떤 집합인지 탐색 (즉, 특정 노드의 루트 노드를 반환)
- 트리 자료구조를 활용하여 집합을 표현

#### 트리를 활용한 유니언 파인드 알고리즘 작동 과정

- union 연산을 활용하여 서로 연결된 두 노드 A, B를 확인
  - A < B 일 때, (숫자가 작을 수록 부모쪽에 위치)
  - A, B 집합의 루트 노드 A' 과 B' 을 찾는다 (find)
  - A' 을 B' 의 부모 노드로 설정한다 (union)
- 모든 union 연산을 수행할 때까지 반복

트리 생성 예시)

```
노드 6개
유니언 데이터
1 4
2 3
2 4
5 6

루트 노드 테이블
노드 번호 1 2 3 4 5 6
루트 번호 1 2 3 4 5 6

1 4 union 연산
노드 번호 1 2 3 4 5 6
루트 번호 1 2 3 1 5 6

1
|
4

2 3 연산
노드 번호 1 2 3 4 5 6
루트 번호 1 2 2 1 5 6

1   2
|   |
4   3

2 4 연산
노드 번호 1 2 3 4 5 6
루트 번호 1 1 2 1 5 6

   1 
 /   \
4     2
      |
      3 

5 6 연산
노드 번호 1 2 3 4 5 6
루트 번호 1 1 1 1 5 5

   1      5
 /   \    |
4     2   6
      |
      3 
```

#### 시간 복잡도

경로 압축했을 떄 O(VM)에서 더 단축 가능

- 대략 O(V + M * logV) 수준

#### 유니언 파인드를 활용한 그래프의 사이클 판별

- 사이클 발생 : 한붓그리기가 가능할 때 (홀수점이 3개 미만)
- 예시

```
사이클 O (한붓그리기 가능 => 홀수점 5, 1 => 2개뿐임)

   1 - 2
 / |   |
5  4 - 3

사이클 X (한붓그리기 불가 => 홀수점 3, 2, 4, 5 => 4개나 됨)

      1
    /   \
   2     3
 /   \
4     5  
```

사이클 판별 동작

- 그래프에 포함된 간선의 갯수가 E개일 때, 모든 간선을 확인하며, 두 노드의 루트 노드 확인 (find)
  - 루트 노드가 서로 다르면) 두 노드를 union
  - 루트 노드가 같으면) 나머지 간선과 관계 없이 한붓그리기가 가능하여 사이클 발생
- 무방향 그래프만 판별 가능

### 2.2. 신장 트리 (Spanning Tree)

어떤 그래프에서 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프

- 모든 노드를 포함하지 않으면 신장 트리가 아니다
- 사이클이 가능해도 (한붓 그리기 가능) 신장 트리가 아니다

즉 신장 트리란, 최소한의 간선으로 모든 노드를 연결하는 그래프 형태이다

### 2.3. 크루스칼 알고리즘 (Kruskal Algorithm)

- `최소 신장 트리 알고리즘`이라고도 함
- 가장 적은 비용으로 신장 트리를 찾아야 할 때 사용
- 그리디 알고리즘 기반

#### 동작 원리

모든 간선을 정렬한 뒤, 가장 거리가 짧은 간선부터 집합에 포함시킨다. 이때 사이클을 발생시키는 경우의 간선은 집합에 포함하지 않는다

- 간선 데이터를 비용에 따라 오름차순 정렬
- 간선을 하나씩 확인하며 사이클을 발생시키는지 확인
  - 사이클 발생 X : 최소 신장 트리에 포함
  - 사이클 발생 O : 포함 X
- 모든 간선에 대해 위 동작을 반복

#### 구현

- `kruskal.py`
- 트리 자료구조의 특성 상 신장 트리를 구성하는 `간선의 갯수`는 `노드 갯수 - 1`과 같다

#### 시간복잡도

- O(E * logE)
- 간선 E개를 정렬하는 작업이 가장 시간이 오래 걸림
