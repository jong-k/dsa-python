# 기타 알고리즘

## 목차

1. 소수 판별

## 1. 소수 판별

### 1.1. 자연수 N이 소수인지 판별하기

#### naive solution

- 구현 : `naive-prime-number.py`
- 2 부터 N - 1 까지 순회하며 N을 나눠보고 하나라도 나머지가 0이면 N은 소수가 아님
- 시간 복잡도 : O(N)
    - 약 N 개의 숫자로 나누는 과정 필요하므로 매우 비효율적

#### N의 제곱근까지만 구하는 방법

가령, 16의 약수들을 살펴보면 아래처럼 대칭된 구조를 이룬다

```
1 x 16 = 16
2 x 8 = 16
4 x 4 = 16 (대칭 기준점)
8 x 2 = 16
16 x 1 = 16
```

N의 약수들은 서로 대칭되기 때문에 루트 N(전체 갯수의 절반)까지만 소수인지 아닌지를 판별해도 된다. 이 경우, 시간 복잡도를 O(N^1/2) 로 줄일 수 있다

- 구현 : `root-prime-number.py`
- 시간 복잡도 : O(N^1/2)
    - 제곱근까지만 확인하면 되서 효율적

### 1.2. 1부터 N까지의 모든 소수 구하기

#### 에라토스테네스의 체

- 자연수 N이 주어질 때, N보다 같거나 작은 모든 소수를 찾을 수 있다

1. 2부터 N까지의 모든 자연수를 나열
2. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾는다
3. 남은 수 중에서 i의 배수를 모두 제거(i는 제거하지 않는다)
4. 더 이상 반복하지 못할 때까지 2번, 3번 과정을 반복

- 구현 : `sieve-of-eratosthenes.py`
- 시간 복잡도 : O(NloglogN)
    - loglogN은 N = 1,000,000 일 때, 약 4 정도로 매우 빠름
- 단점
    - n 크기의 리스트가 필요하기 때문에 메모리를 많이 소요
    - 리스트 최대 길이(약 10억)를 초과하는 n에 대해서 사용 불가