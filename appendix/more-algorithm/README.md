# 기타 알고리즘

## 목차

1. 소수 판별
2. 투포인터
3. 구간 합 계산

## 문제 리스트

`quizs 폴더`

1. 소수 구하기 (백준 1929)
2. 암호 만들기 (백준 1759)

## 1. 소수 판별

### 1.1. 자연수 N이 소수인지 판별하기

#### naive solution

- 구현 : `naive-prime-number.py`
- 2 부터 N - 1 까지 순회하며 N을 나눠보고 하나라도 나머지가 0이면 N은 소수가 아님
- 시간 복잡도 : O(N)
  - 약 N 개의 숫자로 나누는 과정 필요하므로 매우 비효율적

#### N의 제곱근까지만 구하는 방법

가령, 16의 약수들을 살펴보면 아래처럼 대칭된 구조를 이룬다

```
1 x 16 = 16
2 x 8 = 16
4 x 4 = 16 (대칭 기준점)
8 x 2 = 16
16 x 1 = 16
```

N의 약수들은 서로 대칭되기 때문에 루트 N(전체 갯수의 절반)까지만 소수인지 아닌지를 판별해도 된다. 이 경우, 시간 복잡도를 O(N^1/2) 로 줄일 수 있다

- 구현 : `root-prime-number.py`
- 시간 복잡도 : O(N^1/2)
  - 제곱근까지만 확인하면 되서 효율적

### 1.2. 1부터 N까지의 모든 소수 구하기

#### 에라토스테네스의 체

- 자연수 N이 주어질 때, N보다 같거나 작은 모든 소수를 찾을 수 있다

1. 2부터 N까지의 모든 자연수를 나열
2. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾는다
3. 남은 수 중에서 i의 배수를 모두 제거(i는 제거하지 않는다)
4. 더 이상 반복하지 못할 때까지 2번, 3번 과정을 반복

- 구현 : `sieve-of-eratosthenes.py`
- 시간 복잡도 : O(NloglogN)
  - loglogN은 N = 1,000,000 일 때, 약 4 정도로 매우 빠름
- 단점
  - n 크기의 리스트가 필요하기 때문에 메모리를 많이 소요
  - 리스트 최대 길이(약 10억)를 초과하는 n에 대해서 사용 불가

## 2. 투포인터

### 2.1. 특정한 합을 가지는 부분 연속 수열 찾기

리스트에 순차적으로 접근해야 할 때, 2개의 점(시작점, 끝점)의 위치를 기록하면서 처리하는 알고리즘

- 예) 1 2 3 2 5 에서 연속적인 부분 수열의 합이 5인 모든 경우의 수를 찾기 (시작점, 끝점 으로 표현 가능)
- 모든 리스트의 원소가 양수일 때만 사용 가능
  - 합 증가 : end += 1
  - 합 감소 : start += 1 이기 때문

```
아래처럼 3개의 경우의 수가 있을 수 있음
  _ _
1 2 3 2 5

    _ _
1 2 3 2 5

        _
1 2 3 2 5
```

#### 동작 원리

1. 시작점과 끝점 인덱스가 첫 인덱스인 0을 가리키게 한다
2. 현재 부분합이 타겟 부분합 M과 같으면 카운트한다
3. 현재 부분합이 M보다 작으면 end +1 한다 (합 증가)
4. 현재 부분합이 M보다 크거나 같으면 start +1 한다 (합 감소)
5. 모든 경우를 확인할 때까지 2~4번 반복

#### 부분수열의 합 경우의 수 구하기 구현

`two-pointer-1.py`

### 2.2. 정렬된 두 리스트의 합집합 구하기

- 이미 정렬된 2개의 리스트 A, B가 주어짐
- A, B의 모든 원소를 합쳐서 정렬한 결과를 계산
- 2개의 포인터가 각 리스트의 처리되지 않은 원소 중 가장 작은 원소를 가리키게 하여 맨 앞부터 확인한다
- `병합 정렬` 을 구현할 때 사용됨

#### 동작 원리

1. 리스트 A에서 처리되지 않은 원소 중 가장 작은 원소를 i가 가리키게 한다
2. 리스트 B에서 처리되지 않은 원소 중 가장 작은 원소를 j가 가리키게 한다
3. A[i]와 B[j] 중에서 더 작은 원소를 결과 리스트에 담는다
4. 1~3번 과정을 반복한다

#### 합집합 구하기 구현

`two-pointer-2.py`

## 3. 구간 합 계산

- 연속적으로 나열된 N개의 수가 있을 때, (left, right) 형태로 구간 합을 구하는 쿼리 M개가 주어진다
- 시간 복잡도는 O(N * M) 가 된다
  - 만약 N, M 이 백만 이상인 경우에는 O(N * M) 으로는 해결하기 힘들어진다

### 3.1. 접두사 합 (Prefix Sum)

- 빠른 구간합 계산을 위해 N개의 수 위치 각각에 대해 접두사 합을 미리 구해둔다
- 접두사 합 : 리스트 맨 앞부터 특정 위치까지의 합을 구해 놓은 것

### 3.2. Prefix Sum을 활용한 구간 합

#### 동작 원리

1. N개의 수에 대해 prefix sum을 계산하여 배열 P에 저장
2. 매 M개의 쿼리 정보 [left, right] 를 확인할 때, 구간합은 `P[R] - P[L - 1]`

```
원래 리스트
10 20 30 40 50

prefix sum
0 10 30 60 100 150

예제 1
[L, R]
2, 4 -> 20 30 40
4까지의 합 - 2 직전까지의 합 = P[4] - P[1] = 100 - 10
```

#### 구현

`prefix-sum.py`

## 4. 순열과 조합

- Python 3 이상에서 기본 내장된 `itertools` 라이브러리를 활용하면 순열과 조합을 쉽게 활용할 수 있다
- 순열 : `permutation.py`
- 조합 : `combination.py`
