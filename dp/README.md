# 다이나믹 프로그래밍

## 목차

1. 문제 리스트
2. 기본 개념

## 1. 문제 리스트

1. 1로 만들기
2. 개미 전사
3. 바닥 공사
4. 효율적인 화폐 구성
5. 금광
6. 정수 삼각형
7. 퇴사
8. 병사 배치하기
9. 못생긴 수
10. 편집 거리

## 2. 기본 개념

### 2.1. 재귀 점화식의 문제 (feat.피보나치 수열)

- 구현 : `fib-recursive.py`

#### 시간 복잡도

피보나치 수열을 재귀 형태로 구현할 경우 O(2^N)의 시간복잡도가 소요된다 (매우 비효율적)

```
                           f(6)
                       /           \   
                  f(5)              f(4)
                /      \           /     \
             f(4)     f(3)       f(3)     f(2)
            /   \    /   \       /   \
        f(3)   f(2)  f(2) f(1) f(2) f(1)
        /  \
     f(2)  f(1)  
```

- fib(40) 만 구해도 10초 넘게 걸림...

### 2.2. 다이나믹 프로그래밍 (Dynamic Programming)

피보나치 수열 함수를 매번 계산하지 않고, 다이나믹 프로그래밍을 활용하면 문제를 효율적으로 해결할 수 있다

#### 다이나믹 프로그래밍 사용 조건

1. 큰 문제를 작은 문제로 나눌 수 있다
2. 작은 문제에서 구한 정담은 그것을 포함하는 큰 문제에서도 동일하다

#### 메모이제이션 활용

- 메모이제이션 : 한 번 구한 결과를 메모리 공간에 저장해두고 필요할 때 사용하는 것 (=캐싱)
- 메모이제이션을 활용하여 한번 연산한 값을 재사용하면 시간을 획기적으로 줄일 수 있다

#### 피보나치 수열 함수에 메모이제이션 적용

- 구현 : `memoized-fib-recursive.py`
- 시간복잡도 : O(N)

#### Top-Down (하향식)

- 재귀 DP
- 큰 문제를 해결하기 위해 작은 문제를 호출

#### Bottom-Up (상향식)

- 반복 DP
- 작은 문제부터 담을 도출
- 일반적으로 재귀 DP보다 성능이 우수