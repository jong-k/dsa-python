# 정렬

## 목차

1. 문제 리스트
2. 기본 개념

## 1. 문제 리스트

1. 위에서 아래로
2. 성적이 낮은 순서로 학생 출력하기
3. 두 배열의 원소 교체
4. 국영수
5. 안테나
6. 실패율
7. 카드 정렬하기

## 2. 기본 개념

### 2.1. 선택 정렬 (Selection Sort)

#### 동작 원리 (오름차순)

1. 데이터 중 가장 작은 데이터를 선택에 맨 앞 데이터와 바꾼다
2. 정렬되지 않은 데이터들에 대해 이를 반복한다

#### 구현 예시

`selection-sort.py`

#### 시간 복잡도

- O(N^2)
- 선택 정렬 < 퀵 정렬 < 내장 정렬 라이브러리 순으로 수행시간이 나타난다
    - 파이썬 내장 정렬 라이브러리는 내부적으로 C 언어 기반이라 속도가 비교적 빠르다

### 2.2. 삽입 정렬 (Insertion Sort)

#### 동작 원리 (오름차순)

1. 첫번째 데이터는 정렬되어 있다고 가정
2. 다음 데이터를 정렬된 데이터와 비교하여 사이에 (현재는 앞 뒤를 비교) 넣는다
    - 오른쪽에서 왼쪽 방향으로 비교한다
    - 정렬된 데이터는 오름차순 상태를 유지하고 있기 때문에, 특정 데이터를 삽입할 위치를 정할 때 정렬된 데이터가 삽입할 데이터보다 작으면 멈추면 된다
3. 2번을 반복한다

#### 구현 예시

`insertion-sort.py`

#### 시간 복잡도

- O(N^2)
- 삽입 정렬은 선택 정렬에 비해 효율적이거나 비슷하다
- 필요할 때만 위치를 바꾸므로, 데이터가 거의 정렬되어 있을 때 베스트 프랙티스: O(N)로 효율적이다 (탐색 범위가 줄어들기 때문)
    - 선택 정렬은 전 범위 탐색

### 2.3. 퀵 정렬 (Quick Sort)

- 가장 많이 사용되는 정렬 알고리즘 (빠르다)
    - C++, Python, JavaScript(V8 엔진) 등 다수의 프로그래밍 언어에서 sort() 에 퀵 정렬을 채택
- 기준 데이터(pivot)를 설정하고, 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꿔나간다

#### 동작 원리 (오름차순)

1. 첫 번째 원소를 피벗(pivot)으로 삼는다
2. 2번째 원소부터 오른쪽 방향으로 순회하며 피벗보다 큰 원소를 찾는다
3. 마지막 원소부터 왼쪽 방향으로 순회하며 피벗보다 작은 원소를 찾는다
4. 이 때 인덱스가 엇갈리지 않으면 두 원소를 스왑한다. 만약, 엇갈렸다면, 작은 원소과 피벗을 스왑한다
5. 피벗 좌측 배열, 우측 배열에 대해 정렬을 반복한다. 배열의 길이가 1이면 종료한다.

```py
"""
1트

pivot
_
4 1 2 3 5 6 7
  L->     <-R

4 1 2 3 5 6 7
      R L
=> 엇갈렸으므로 피벗과 작은 값 R(3)을 스왑

      pivot
      _
3 1 2 4 5 6 7      
 좌측 | | 우측 나눠서 다시 정렬 시시시작~

2트 왼쪽

pivot
_
3 1 2
  L R

pivot
_
3 1 2
    R
      L
=> 엇갈렸으므로 R과 L을 스왑

2 1 3
좌 | 우 나눠서 재 실행 => 이후 2 1 은 1 2 로 정렬됨

2트 오른쪽
pivot
_
5 6 7
  L R

_
5 6 7
R     L

=> 엇갈렸으므로 pivot과 R을 스왑 (의미 없음)
=> 5 6 7

이후 5, 6 7 로 나눠서 재정렬 실행
"""
```

#### 구현 예시

- `quick-sort.py` : 오리지널 퀵 정렬
- `pythonic-quick-sort.py` : 파이써닉 퀵 정렬 (약간 비효율적이나 가독성 우수)

#### 시간 복잡도

- O(NlogN) (평균)
    - 배열이 거의 정렬된 형태라면 O(N^2) 까지 걸릴 수 있음
    - 따라서 Python 내장 정렬 라이브러리에서는 worst case에도 O(NlogN)이 되도록 pivot 선택 시 추가적인 로직을 더해줌
- 선택 정렬이나 삽입 정렬은 고르게 O(N^2)의 시간 복잡도를 보임

### 2.4. 계수 정렬(count sort)

- 특정 조건(정수 데이터)에서만 사용할 수 있지만, 매우 빠르다 (O(N + K), K는 최댓값)
    - 예) 0이상 100 이하인 성적 데이터 정렬
    - 일반적으로 최댓값 최솟값 차가 100만 이하일 때 가장 효율적
    - 최댓값 최솟값 차이 만큼의 길이의 리스트를 선언해야 하기 때문

#### 구현 예시

`count-sort.py`

#### 시간 복잡도

- O(N+K), K: 데이터의 최댓값의 크기
- 기수 정렬(radix sort)와 더불어 가장 빠른 알고리즘

#### 공간 복잡도

- 데이터가 양 극단에 있을 경우 비효율적
    - 예) 0과 999999 로 이루어진 데이터를 처리할 때도 크기가 100만인 리스트 필요
- 제한된 범위에서 중복된 데이터가 많을 떄 효율적

### 2.5. 파이썬 정렬 라이브러리

#### sorted(), sort() : O(nlogn)

- 병합 정렬(merge sort)를 기반으로 만들어짐(퀵 정렬과 비슷한)
- 일반적으로 퀵 정렬보다 느리지만, worst case 에도 O(nlogn) 을 보장